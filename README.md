~~# Лабораторная работа №9-10: Продвинутое ООП на Kotlin
## Описание
Лабораторная работа посвящена изучению продвинутых концепций объектно-ориентированногопрограммирования в Kotlin. ## Структура проекта
Проект содержит примеры реализации продвинутых механизмов ООП, а также пояснения к ключевымконцепциям. ## Как запустить проект
1. Клонируйте репозиторий: ```bash
git clone <URL_репозитория>
``` 2. Откройте проект в IntelliJ IDEA. 3. Запустите любой пример через контекстное меню или напрямую из `main`. 
2. ## Автор Плеско Д.
## Лицензия
Проект создан в учебных целях.

## Геттеры и сеттеры
Геттеры и сеттеры позволяют управлять доступом к свойствам.
Кастомный сеттер используется для валидации или ограничения значения.
Пример:
```kotlin
var age: Int = 18
 set(value) {
 if (value > 0 && value < 110) field = value
 }
fun main() {
 println(age) // 18
 age = 45
 println(age) // 45
 age = -345
 println(age) // 45 (не изменилось)
}
```
## Инкапсуляция
Инкапсуляция скрывает внутреннее состояние объекта.
Реализуется через модификаторы доступа и кастомные аксессоры.
Пример:
```kotlin
var level: Int = 1
 private set // только класс может изменять уровень
fun levelUp() {
 level++
 println("Уровень повышен до $level")
}
```
## Data-классы
Data-классы автоматически генерируют equals(), hashCode(),
toString(), copy(). Идеально подходят для хранения данных.
Пример:
```kotlin
data class Task(
 val id: Int,
 val name: String,
 val quantity: Int
)
val task = Task(1, "Work", 5)
val taskCopy = task.copy(quantity = 10)
println(task) // Task(id=1, name=Work, quantity=5)
println(taskCopy) // Task(id=1, name=Work, quantity=10)
```
## Абстрактные классы
Абстрактный класс нельзя создать напрямую. Он задаёт структуру
для подклассов и может содержать реализованные и абстрактные методы.
Пример:
```kotlin
abstract class Figure {
 abstract fun area(): Float
 abstract fun perimeter(): Float
}
class Rectangle(val w: Float, val h: Float) : Figure() {
 override fun area() = w * h
 override fun perimeter() = 2 * (w + h)
}
```
## Интерфейсы
Интерфейс — контракт поведения. Один класс может реализовывать
несколько интерфейсов, что решает проблему множественного наследования.
Пример:
```kotlin
interface VideoPlayable {
 fun play() = println("Play video")
}
interface AudioPlayable {
 fun play() = println("Play audio")
}
class MediaPlayer : VideoPlayable, AudioPlayable {
 override fun play() {
 println("Start playing")
 super<VideoPlayable>.play()
 super<AudioPlayable>.play()
 }
}
```
## Как запустить проект
1. Клонируйте репозиторий: git clone <URL>
2. Откройте проект в IntelliJ IDEA
3. Запустите Main.kt

# Galaxy Outpost Manager
***
Учебный проект на Kotlin, демонстрирующий основы объектноориентированного
программирования и архитектурные приёмы языка.
***
## Sealed-классы
***
**Sealed-классы** используются для представления ограниченного набора
состояний
или результатов, которые известны на этапе компиляции. Они позволяют:
- гарантировать обработку всех возможных вариантов;
- безопасно использовать конструкцию `when` без `else`;
- удобно описывать состояния, события и результаты действий.
### Пример: результат работы модуля
``` kotlin
sealed class ModuleResult {
data class Success(val message: String) : ModuleResult()
data class ResourceProduced(val resourceName: String, val amount:
Int) : ModuleResult()
data class NotEnoughResources(
val resourceName: String, val required: Int, val available:
Int
) : ModuleResult()
data class Error(val reason: String) : ModuleResult()
}
```
## Object в Kotlin
***
**object** — это специальная конструкция Kotlin, которая создаёт
единственный
экземпляр класса (Singleton).

Особенности:
- создается при первом обращении
- существует в одном экземпляре
- не имеет конструктора
### Пример: глобальный логгер
```
object Logger {
private var counter = 0
fun log(message: String) {
counter++
println("[$counter] $message")
}
}
Logger.log("Инициализация системы")
Logger.log("Модуль запущен")
```
### Использование:
```
Logger.log("Инициализация системы")
Logger.log("Модуль запущен")
```
**object** удобно использовать для:
- логгеров;
- конфигураций;
- состояний без данных в sealed-классах;
- утилитарных классов.
***
### Делегирование свойств 
**Делегирование свойств** позволяет передать логику хранения и обработки значения другому объекту. В Kotlin это реализуется с помощью ключевого слова by. Преимущества: уменьшение дублирования кода;
централизованная логика проверки и обработки данных, более чистый и читаемый код. 
**Пример:** ограничение диапазона значения энергии
``` kotlin
var energy: Int by Delegates.observable(100) { _, old, new ->
println("Энергия изменилась: $old → $new")
}
```
### Lazy (ленивая инициализация)
**lazy** позволяет инициализировать объект только при первом обращении к нему. Это полезно, если: объект создаётся не всегда;
его создание ресурсоёмкое; нужно отложить инициализацию. 
**Пример:** 
``` kotlin
val resourceManager by lazy {
ResourceManager()
}
```
**Объект ResourceManager** будет создан только при первом использовании. 
### Observer-паттерн (наблюдатель)
**Observer-паттерн** позволяет объектам реагировать на изменения состояния другого объекта. В проекте Galaxy Outpost Manager наблюдатели могут: реагировать на изменение ресурсов; логировать события;
уведомлять пользователя. Пример идеи: ResourceManager изменяет ресурсы; наблюдатель выводит сообщение в консоль при изменении. Сохранение состояния Для сохранения состояния проекта используется сериализация в JSON. Это позволяет: сохранять данные между запусками программы; хранить состояние в человекочитаемом формате; легко перенести логику в Android-приложение